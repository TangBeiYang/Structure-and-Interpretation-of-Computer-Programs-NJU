; ============================================
; 宏(Macros) - Scheme 元编程总结
; ============================================

; ============================================
; 1. 表达式作为数据(Expressions as Data)
; ============================================

; 在Scheme中，表达式可以是原始值或列表，这意味着表达式也是一种数据形式
; 我们可以：
; 1. 将表达式赋值给变量
; 2. 将表达式传递给函数
; 3. 在函数内创建和返回新的表达式

; 1.1 引用表达式
'(+ 1 2)                      ; => (+ 1 2) - 引用防止求值
(list 'quotient 10 2)        ; => (quotient 10 2) - 构造表达式列表

; 1.2 eval函数：对未求值的表达式进行求值
(eval '(+ 1 2))              ; => 3
(eval (list 'quotient 10 2)) ; => 5

; ============================================
; 2. begin 特殊形式
; ============================================

; begin特殊形式接收任意数量的表达式，按顺序求值，返回最后一个表达式的值
(begin 3 2 1)                ; => 1

; 示例：在begin中定义变量并计算
(begin
  (define x 2)               ; 定义x为2
  (define x (+ x 1))         ; 重新定义x为3
  x)                         ; => 3

; ============================================
; 3. let 特殊形式
; ============================================

; let用于创建局部绑定，语法：
; (let ((symbol1 expr1)
;       (symbol2 expr2)
;       ...)
;   body)

; 示例：
(let ((x 2)                  ; 局部绑定x=2
      (y 3))                 ; 局部绑定y=3
  (+ x y))                   ; => 5

; 特点：
; 1. 所有绑定并行计算（expr1, expr2...同时求值）
; 2. 绑定只在body求值时存在
; 3. body中可以使用这些局部变量

; ============================================
; 4. 宏(Macros)基础
; ============================================

; 4.1 问题示例：double过程
; 目标：写一个过程double，使其对传入的表达式求值两次
; 例如：(double (print 2)) 应该打印两次2

; 问题：
; 1. 如何防止输入表达式被立即求值？
; 2. 如何轻松实现预期行为？

; ============================================
; 5. 宏的定义与使用
; ============================================

; 5.1 define-macro特殊形式
; 宏是转换或创建表达式的更方便的方式
; define-macro创建宏过程，宏接收和返回表达式

; 定义twice宏：对表达式求值两次
(define-macro (twice expr)
  (list 'begin expr expr))   ; 返回(begin expr expr)

; 使用示例：
(twice (print 2))            ; 展开为：(begin (print 2) (print 2))
; 结果：打印两次2

; ============================================
; 6. 宏的求值过程
; ============================================

; 普通函数调用表达式求值过程：
; 1. 求值运算符子表达式，得到普通过程
; 2. 按顺序求值所有操作数表达式
; 3. 将过程应用于已求值的操作数

; 宏的求值过程：
; 1. 求值运算符子表达式，得到宏过程
; 2. 将宏过程应用于操作数表达式（不先求值操作数！）
; 3. 在宏被调用的框架中求值宏返回的表达式

; ============================================
; 7. 宏的编写技巧
; ============================================

; 编写宏时应考虑：
; 1. 将接收什么类型的表达式
; 2. 什么表达式具有与宏等效的行为

; 7.1 示例：add-to宏
; 功能：接收一个符号和一个表达式，将变量的值增加表达式的值
(define-macro (add-to sym expr)
  (list 'define sym (list '+ sym expr)))

; 使用示例：
(define x 1)                 ; x = 1
(add-to x (+ 1 2))           ; 展开为：(define x (+ x (+ 1 2)))
; 结果：x = 4

; ============================================
; 8. 宏的高级应用：实现for循环
; ============================================

; Scheme没有for循环，但可以通过宏添加
; 目标：(for x in '(1 2 3 4) do (* x x)) 返回 (1 4 9 16)

; 8.1 使用map实现for循环
; 等价表达式：(map (lambda (x) (* x x)) '(1 2 3 4))
(define-macro (for sym in vals do expr)
  (list 'map (list 'lambda (list sym) expr) vals))

; ============================================
; 9. 准引用(Quasiquoting)
; ============================================

; 准引用允许列表中的某些部分被字面读取，某些部分被求值
; 对于在宏中构造代码特别有用

; 9.1 准引用语法
; `(quasiquote) 用于准引用
; ,(unquote) 用于在准引用中插入求值表达式

; 9.2 使用准引用改进for宏
; 原始版本：
(define-macro (for-old sym vals expr)
  (list 'map (list 'lambda (list sym) expr) vals))

; 使用准引用的版本：
(define-macro (for sym vals expr)
  `(map (lambda (,sym) ,expr) ,vals))

; 更清晰、更易读

; ============================================
; 10. 练习：使用准引用重写宏
; ============================================

; 10.1 重写twice宏
; 原始：
(define-macro (twice-old expr)
  (list 'begin expr expr))

; 使用准引用：
(define-macro (twice expr)
  `(begin ,expr ,expr))

; 10.2 重写add-to宏
; 原始：
(define-macro (add-to-old sym expr)
  (list 'define sym (list '+ sym expr)))

; 使用准引用：
(define-macro (add-to sym expr)
  `(define ,sym (+ ,sym ,expr)))

; ============================================
; 11. 要点总结
; ============================================

; 1. 表达式即数据：
;    - Scheme中表达式可以是列表，因此可以像数据一样操作
;    - 引用防止表达式被求值，eval对未求值表达式求值

; 2. 特殊形式：
;    - begin：按顺序求值多个表达式，返回最后一个的值
;    - let：创建局部绑定，绑定并行求值，只在body中存在

; 3. 宏：
;    - 宏是元编程工具，接收和返回表达式
;    - define-macro定义宏
;    - 宏的求值过程：不先求值操作数，而是先展开宏，然后求值展开后的表达式

; 4. 宏编写：
;    - 思考宏接收的表达式类型和等效行为
;    - 可以用宏扩展语言功能（如实现for循环）

; 5. 准引用：
;    - 简化宏编写，使代码更清晰
;    - 使用`(quasiquote)创建模板，,(unquote)插入求值部分

; 6. 宏 vs 函数：
;    - 宏操作表达式，在求值前展开
;    - 函数操作值，参数先求值再传递
;    - 宏可以创建新的语法结构，函数不能
