; ============================================
; 解释器(Interpreters) 
; ============================================

; ============================================
; 1. 翻译问题与解决方案
; ============================================

; 问题:
; - 计算机只理解二进制(0和1)
; - 人类难以直接用二进制编程

; 解决方案:
; - 使用编程语言(Python、Java、C等)
; - 将高级语言翻译成二进制

; 翻译方式:
; 1. 编译(Compiled): 一次性翻译，之后运行
; 2. 解释(Interpreted): 运行时逐行翻译 ← 本节重点

; ============================================
; 2. 解释器(Interpreter)的基本结构
; ============================================

; 解释器做三件事:
; 1. 读取(Read): 读取用户输入的特定编程语言代码
; 2. 求值(Eval): 翻译输入为计算机可读形式并求值
; 3. 打印(Print): 为用户打印结果

; 涉及两种语言:
; - 实现语言(Implemented Language): 用户输入的语言(如Scheme)
; - 实现所用语言(Implementation Language): 解释器实现的语言(如Python)

; ============================================
; 3. 读取-求值-打印循环(REPL) -- 核心逻辑
; ============================================

; REPL工作流程:
; while True:
;     exp = read()    ; 读取表达式
;     val = eval(exp) ; 求值表达式
;     print(val)      ; 打印结果

; ============================================
; 4. 读取阶段(Read)
; ============================================

; 4.1 词法分析(Lexer)
; - 将输入字符串转换为标记(token)集合
; - 标记: 单个输入单元(字面量、名称、关键字、分隔符)

; 4.2 语法分析(Parser)
; - 将标记转换为实现语言中的表达式表示
; - 表示形式取决于表达式类型

; 输入字符串 → 读取器 → 词法分析器 → 标记 → 语法分析器 → 表达式表示

; ============================================
; 5. Scheme表达式的Python表示
; ============================================

; 5.1 原始表达式表示
; - 自求值表达式(布尔值和数字): 使用Python布尔值和数字
;   #t → True, 5.2 → 5.2
; - 符号: 使用Python字符串
;   'cons' → 'cons'

; 5.2 组合表达式表示
; Scheme: (+ 2 3)
; 简单Python表示: ['+', 2, 3] 但不精确(不是链表)

; 5.3 精确表示: 使用Pair类
; 定义Pair类表示Scheme链表:
class Pair:
    def __init__(self, first, second):
        self.first = first    ; 第一个元素
        self.second = second  ; 第二个元素(另一个Pair或nil)

; nil类表示空列表:
class nil:
    def __repr__(self):
        return 'nil'
nil = nil()  ; 单例实例

; Scheme组合的精确表示:
; (+ 2 3) → Pair('+', Pair(2, Pair(3, nil)))

; ============================================
; 6. 读取组合表达式
; ============================================

; 输入: (+ 2 3)
; 词法分析: ['(','+', 2, 3, ')']
; 语法分析: Pair('+', Pair(2, Pair(3, nil)))

; 输入: (define (f) 3)
; 词法分析: ['(','define','(','f',')', 3, ')']
; 语法分析: Pair('define', Pair(Pair('f', nil), Pair(3, nil)))

; ============================================
; 7. 特殊处理: 引用(quote)
; ============================================

; quote有两种写法:
; 1. (quote <expr>)  如: (quote hello)
; 2. '<expr>         如: 'hello

; 在读取阶段，引用的特殊语法被转换为quote表达式:
; 'hello → Pair('quote', Pair('hello', nil))
; '(+ 2 3) → Pair('quote', Pair(Pair('+', Pair(2, Pair(3, nil))), nil))

; ============================================
; 8. 表达式表示练习
; ============================================

; 1) 4.67 → 4.67 (Python浮点数)
; 2) #t → True (Python布尔值)
; 3) list → 'list' (Python字符串)
; 4) (cons 2 3) → Pair('cons', Pair(2, Pair(3, nil)))
; 5) (if (< x 0) 1 (+ x 1)) → 
;    Pair('if', Pair(Pair('<', Pair('x', Pair(0, nil))), 
;                   Pair(1, Pair(Pair('+', Pair('x', Pair(1, nil))), nil))))
; 6) 'hello → Pair('quote', Pair('hello', nil))

; ============================================
; 9. 求值阶段(Eval)
; ============================================

; 表达式求值规则取决于表达式类型:
; 1. 自求值表达式
; 2. 符号
; 3. 调用表达式
; 4. 特殊形式表达式

; Eval函数需要一个额外参数: 当前环境(current environment)

; ============================================
; 10. 框架(Frames)与环境(Environments)
; ============================================

; 环境: 当前框架、其父框架、直到全局框架的所有祖先框架

; 示例:
(define (make-adder x)
  (lambda (y) (+ x y)))

(define add-three (make-adder 3))
(add-three 5)  ; → 8
(add-three 10) ; → 13

; 环境结构:
; 全局框架: make-adder, add-three
; f1框架(x=3): 返回lambda过程
; f2框架(y=5): 计算(+ 3 5)
; f3框架(y=10): 计算(+ 3 10)

; ============================================
; 11. 框架的Python表示
; ============================================

class Frame:
    def __init__(self, parent):
        self.bindings = {}  ; 字典: 符号→值
        self.parent = parent ; 父框架(另一个Frame实例)

; 求值器需要当前环境(单个Frame实例)来查找表达式中的名称

; ============================================
; 12. 原始表达式的求值
; ============================================

; 12.1 自求值表达式
; - 求值为它们自身
; - 4.65 → 4.65

; 12.2 符号
; 1. 在当前框架中查找符号
; 2. 如果未找到，在父框架中查找，依此类推
; 3. 如果到达全局框架仍未找到，报错

; ============================================
; 13. 组合表达式的求值
; ============================================

; 格式: (<operator> <operand1> <operand2> ...)
; 操作符决定是特殊形式还是调用表达式

; 13.1 如果是特殊形式
; - 在特殊形式字典中查找操作符
; - 每个特殊形式有特殊的求值规则

; 13.2 如果是调用表达式
; 步骤1: 求值操作符得到过程
; 步骤2: 从左到右求值所有操作数
; 步骤3: 将过程应用于操作数的值

; ============================================
; 14. 过程类型
; ============================================

; 14.1 内置过程(Built-in Procedures)
; - 预定义在Scheme解释器中(如+, list, modulo)
; - 对应执行相应操作的Python函数
; - 表示为BuiltinProcedure类的实例

; 14.2 用户定义过程(User-defined Procedures)
; - 用户通过lambda或define定义
; - 包含: 形式参数列表、函数体(Scheme列表)、父框架
; - 表示为LambdaProcedure类的实例

; ============================================
; 15. 过程应用
; ============================================

; 15.1 内置过程应用
; - 调用实现内置过程的Python函数

; 示例: (+ 4 (* 2 3))
; 求值: 4, (* 2 3) → 6
; 应用: scheme_add(4, 6) → 10

; 15.2 用户定义过程应用
; 步骤1: 打开新框架，父框架为过程的父框架
; 步骤2: 在新框架中将形式参数绑定到实参
; 步骤3: 在新框架中求值过程体

; 示例: (square 5) 其中 (define (square x) (* x x))
; 1. 创建新框架，父框架为全局框架
; 2. 绑定x=5
; 3. 求值(* x x) → 25

; ============================================
; 16. 求值器的结构
; ============================================

; 求值器由两个相互递归的组件组成:

; 16.1 Eval(求值)
; 基本情况:
; - 自求值表达式
; - 查找绑定到符号的值
; 递归情况:
; - 求值操作符和操作数
; - 应用过程
; - 求值特殊形式的表达式体

; 16.2 Apply(应用)
; 基本情况:
; - 内置过程
; 递归情况:
; - 求值用户定义过程的函数体

; ============================================
; 17. eval/apply调用计数
; ============================================

; 17.1 内置过程示例: (+ 2 (* 4 1) 5)
; eval调用: 8次
; apply调用: 2次
; 详细过程:
; 1. eval整个表达式
; 2. eval '+' (得到BuiltinProc)
; 3. eval 2
; 4. eval (* 4 1)子表达式
;    - eval '*'
;    - eval 4
;    - eval 1
;    - apply(scheme_mul, [4, 1]) → 4
; 5. eval 5
; 6. apply(scheme_add, [2, 4, 5]) → 11

; 17.2 用户定义过程示例: (* (f 3) 2)
; 假设: (define (f x) (+ x 1)) 已定义
; eval调用: 10次
; apply调用: 3次
; 详细过程:
; 1. eval '*'
; 2. eval (f 3)子表达式
;    - eval 'f' (得到lambda过程)
;    - eval 3
;    - apply(lambda, 3) → 创建新框架，求值(+ x 1)
;      - eval '+'
;      - eval 'x'
;      - eval 1
;      - apply(scheme_add, [3, 1]) → 4
; 3. eval 2
; 4. apply(scheme_mul, [4, 2]) → 8

; ============================================
; 关键概念总结
; ============================================

; 1. 解释器工作流程: 读取→求值→打印(REPL循环)
; 2. 词法分析和语法分析将输入转换为内部表示
; 3. Scheme表达式用Pair类和nil单例精确表示
; 4. 求值需要环境(框架链)来处理变量绑定
; 5. 两种过程类型: 内置过程和用户定义过程
; 6. 求值器由Eval和Apply两个相互递归的函数组成
; 7. 理解eval/apply调用计数有助于理解解释器工作原理
