; ============================================
; Scheme 进阶 - 列表与尾递归总结
; ============================================

; ============================================
; 1. 点对(Pairs)和列表(Lists)
; ============================================

; 1.1 点对的基本操作
; cons: 构造点对 (construct pair)
; car: 获取点对的第一个元素
; cdr: 获取点对的第二个元素

(define x (cons 1 (cons 3 nil)))  ; 创建点对: 1 → 3 → nil
x                                 ; => (1 3) - 打印表示
(car x)                           ; => 1 - 获取第一个元素
(cdr x)                           ; => (3) - 获取第二个元素(也是一个点对)

; 点对结构: 第二个元素必须是另一个点对或nil(空列表)

; ============================================
; 2. 列表的定义与构建
; ============================================

; 2.1 列表的本质
; - Scheme中唯一的序列类型是链表(linked list)
; - 通过多个cons表达式构建
; - nil表示空列表(可用null?方法来判断list是否为空)

; 2.2 列表的内存表示
; (cons 2 nil) 的链表表示: 2 → nil
; (cons 1 (cons 2 nil)) 的链表表示: 1 → 2 → nil

; 补充：list中car第一个元素也可能是一个链表

; ============================================
; 3. 符号编程(Symbolic Programming)
; ============================================

; 3.1 引用的概念
; 符号通常引用值，但有时我们需要直接引用符号本身
; 使用引用(quotation)来直接引用符号

(define a 1)                      ; 定义符号a绑定到值1
(define b 2)                      ; 定义符号b绑定到值2
(list a b)                       ; => (1 2) - 获取的是值，不是符号

; 3.2 引用语法
; 'a 是 (quote a) 的简写
; 引用是一种特殊形式，表示表达式本身就是值(不求值)

(list 'a 'b)                     ; => (a b) - 直接引用符号a和b
(list 'a b)                      ; => (a 2) - a是符号，b是值

; 3.3 对组合表达式使用引用
'(a b c)                         ; => (a b c) - 整个列表都不求值
(car '(a b c))                   ; => a - 获取第一个符号
(cdr '(a b c))                   ; => (b c) - 获取剩余符号

; ============================================
; 4. 尾递归(Tail Recursion)
; ============================================

; 4.1 尾递归的基本概念
; - 尾上下文(tail context): 表达式是函数调用中的最后一步
; - 尾调用(tail call): 尾上下文中的函数调用
; - 尾递归(tail recursive): 尾调用调用函数自身
; - 尾调用优化: 语言支持时，尾递归函数只使用常量数量的栈帧

; 4.2 识别尾上下文
; 表达式在尾上下文中的条件是：
; 它是每个可能场景I(任何场景)中最后求值的东西(之后没有其他操作)

; 示例分析：
; (and expr1 expr2 expr3)   ; expr3在尾上下文
; (if expr1 expr2 expr3)    ; expr2和expr3在尾上下文
; (+ expr1 expr2)           ; expr1与expr2均不为尾上下文
; ((lambda (expr1) expr1) expr2) ; expr1在尾上下文

; ============================================
; 5. 普通递归 vs 尾递归对比
; ============================================

; 5.1 普通递归阶乘函数(非尾递归)
(define (fact n)
    (if (= n 0)
        1
        (* n (fact (- n 1)))))  ; 递归调用后还需要乘法操作

; 调用 (fact 4) 时的栈帧情况：
; f1: fact(4) -> 等待 4 * fact(3)
; f2: fact(3) -> 等待 3 * fact(2)
; f3: fact(2) -> 等待 2 * fact(1)
; f4: fact(1) -> 等待 1 * fact(0)
; f5: fact(0) -> 返回1
; 然后逐层返回并相乘，需要保持所有栈帧

; 5.2 尾递归阶乘函数
(define (fact-tail n)
    (define (helper n result)     ; 辅助函数，result累积结果
        (if (<= n 1)
            result                ; 基本情况：返回累积结果
            (helper (- n 1) (* n result))))  ; 尾递归调用  
    (helper n 1))                 ; 初始调用，result初始为1

; 调用 (fact-tail 4) 时的栈帧情况：
; f1: helper(4, 1) -> 调用helper(3, 4)
; f2: helper(3, 4) -> 调用helper(2, 12)
; f3: helper(2, 12) -> 调用helper(1, 24)
; f4: helper(1, 24) -> 返回24
; 每个调用都是尾调用，栈帧可以重用(尾递归优化的原因)，只需常量空间

; ============================================
; 6. 编写尾递归函数的步骤
; ============================================

; 6.1 尾递归函数编写步骤：
; 1) 识别非尾上下文的递归调用
; 2) 创建辅助函数，添加累积参数来保存中间结果
; 3) 确保递归调用是最后一步操作(在尾上下文)

; 6.2 尾上下文的常见位置：
; - lambda函数体的最后一个子表达式
; - if表达式的then和else分支(当if本身在尾上下文中时)
; - and/or/begin/let表达式的最后一个子表达式(当这些表达式在尾上下文中时)

; ============================================
; 7. 尾递归示例：计算列表长度
; ============================================

; 7.1 普通递归版本(非尾递归)
(define (length-nontail lst)
    (if (null? lst)
        0
        (+ 1 (length-nontail (cdr lst)))))  ; 递归调用后需要+1操作

; 7.2 尾递归版本
(define (length-tail lst)
    (define (helper lst count)              ; 辅助函数，count累积长度
        (if (null? lst)
            count                           ; 空列表时返回累积长度
            (helper (cdr lst) (+ 1 count)))) ; 尾递归调用
    (helper lst 0))                         ; 初始调用，count初始为0

; 测试：
(length-tail '())                           ; => 0
(length-tail '(1 2 (3 4)))                  ; => 3

; ============================================
; 8. 尾递归的特点总结
; ============================================

; 1. 空间效率：
;    - 普通递归：需要O(n)栈空间(n为递归深度)
;    - 尾递归：在支持尾调用优化的语言中，只需O(1)栈空间

; 2. 识别方法：
;    - 递归调用后是否还有其他操作
;    - 递归调用的结果是否直接返回(不参与其他计算)

; 3. 转换技巧：
;    - 添加累积参数(accumulator)保存中间结果
;    - 使用辅助函数进行递归
;    - 初始调用提供累积参数的初始值

; 4. Scheme中的重要性：
;    - Scheme没有内置的循环结构
;    - 尾递归是实现迭代计算的标准方式
;    - 支持尾调用优化，确保高效执行
